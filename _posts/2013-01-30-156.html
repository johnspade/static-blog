---
layout: post
title: |-
  [Javascript] Получение данных из профиля Steam
date: 2013-01-30 22:58:00
tags: 
  - софт
  - игры
  - проекты
  - javascript
  - программирование
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-w2Za_tgInnc/UQkUmXDAaaI/AAAAAAAAFFU/UtwhlpNoBc8/s1600/csslnch.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-w2Za_tgInnc/UQkUmXDAaaI/AAAAAAAAFFU/UtwhlpNoBc8/s1600/csslnch.PNG" /></a></div>В <a href="/posts/155">прошлой записи</a> я писал, что собираюсь доделать гаджет из этой статьи: <a href="/posts/151">Пишем гаджет Windows 7</a>. И я наконец выполнил свое намерение, теперь гаджет выводит время, проведенное в игре. Результат можно увидеть на картинке выше.<br /><br /><a name="more"></a><div>Данные гаджет берет из Стима. Как указано в документации, Steam отдает данные о профиле в XML-формате по ссылкам вида <code>http://steamcommunity.com/profiles/&lt;SteamID&gt;/?xml=1</code> или <code>http://steamcommunity.com/id/&lt;CustomURL&gt;/?xml=1</code>. Также мы можем получить статистику пользователя в конкретной игре по ссылкам вида <code>http://steamcommunity.com/profiles/&lt;SteamID&gt;/stats/&lt;CommunityGameName&gt;/?xml=1</code> или <code>http://steamcommunity.com/id/&lt;CustomURL&gt;/stats/&lt;CommunityGameName&gt;/?xml=1</code>. Для большинства игр в статистике есть только информация по достижениям, но для некоторых игр указаны и другие данные. Так, у Counter-Strike: Source в статистике есть общее время, проведенное в игре. Для профиля данные по игре будут доступны только в том случае, если пользователь играл в нее в последние две недели, и игра отображается на странице его профиля. Поэтому XML профиля не годится как постоянный источник данных для гаджета.<br /><br />У статистики другая проблема. В XML профиля указывается то количество часов, которое вы видите в своей библиотеке Steam, открывая страницу игры. В статистике же указывается другое время, и обычно оно меньше. Я не знаю, по каким принципам считается количество часов, могу сказать только, что разброс данных может быть большим. Для моего профиля разница составляет ~20 часов. У одного человека из моего списка друзей в профиле указано 600+ часов для CS:S, в статистике же только 90 часов. Исходя из этих соображений, я решил дать пользователю выбор источника данных. На этом сбор информации можно считать завершенным, переходим к написанию кода.<br /><br />Страничка гаджета мной уже была написана, об этом можно почитать в статье "<a href="/posts/151">Пишем гаджет Windows 7</a>". Добавим на нее никнейм пользователя, кнопку "Обновить" и место для вывода количества часов:</div><pre>&lt;p id="service"&gt;<br />	&lt;span id="nick"&gt;&lt;/span&gt;<br />	 | <br />	&lt;span id="refresh" onclick="work()"&gt;<br />	&lt;a href="#"&gt;Обновить&lt;/a&gt;<br />	&lt;/span&gt;<br />&lt;/p&gt;<br />&lt;h3 id="digits"&gt;&lt;/h3&gt;</pre>По клику на "Обновить" выполняется главная функция, в которой и будет происходить загрузка и обработка данных. Ее мы напишем чуть позже. Эти элементы абсолютно позиционированы с помощью стилей. Должен сказать, позиционирование в гаджете ведет себя странно. Надежнее всего указывать точные расстояния в пикселях, иначе вообще неизвестно, где окажутся ваши элементы. При этом, если открыть страничку в браузере и сравнить с гаджетом, они будут в разных местах. В начале я долго не мог понять, почему гаджет ничего не показывает, а потом оказалось, что он просто выводит данные за границами гаджета, так что их просто не было видно. В общем, значения расстояний я рассчитал подбором.<br /><br />Для того, чтобы загружать данные, нужно знать никнейм пользователя и выбранный источник. Для этого создадим страницу настроек. Это тоже простая html-страничка, на которой я разместил текстовый инпут и выпадающий список:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/--3S-nSkLkSY/UQkm9sUvlnI/AAAAAAAAFGE/dc6hbUF4Aqw/s1600/Image+016.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/--3S-nSkLkSY/UQkm9sUvlnI/AAAAAAAAFGE/dc6hbUF4Aqw/s1600/Image+016.png" /></a></div><pre>&lt;form action="#"&gt;<br />	&lt;p class="settingsP"&gt;<br />		Никнейм или ID:<br />		&lt;input type="text" name="nickname" id="nickname"&gt;<br />	&lt;/p&gt;<br />	&lt;p class="settingsP"&gt;<br />		Источник данных:<br />		&lt;select name="source" id="source"&gt;<br />			&lt;option value="stats"&gt;Статистика&lt;/option&gt;<br />			&lt;option value="profile"&gt;Профиль&lt;/option&gt;<br />		&lt;/select&gt;<br />	&lt;/p&gt;<br />&lt;/form&gt;</pre>Не забудьте в стилях указать точные размеры для окна настроек. Кнопки "ОК" и "Отмена" система создает сама. Теперь напишем скрипт для сохранения настроек. Сохранить настройки для гаджета можно с помощью специального метода <code>System.Gadget.Settings.writeString('name', data)</code>, а потом прочитать с помощью <code>System.Gadget.Settings.readString('name')</code>. При закрытии гаджета настройки сбрасываются, чтобы этого избежать, для их сохранения можно использовать файлы. Я решил, что обойдусь без этого. Если пользователь нажимает "ОК", свойство <code>.closeAction</code> объекта event становится равным <code>.Action.commit</code>. Итак, создаем .js-файлик и подключаем к странице настроек: <br /><pre>// Выводим на страницу старые настройки<br />nicknameOld = System.Gadget.Settings.readString('nickname');<br />selectedSourceOld = System.Gadget.Settings.readString('source');<br />document.getElementById('nickname').value = nicknameOld;<br />if (selectedSourceOld == 'stats') {<br />	document.getElementById('source').selectedIndex = 0;<br />}<br />else {<br />	document.getElementById('source').selectedIndex = 1;<br />}<br />// Если пользователь нажал OK, сохраняем настройки<br />function settingsClosing(event) {<br />	if (event.closeAction == event.Action.commit) {<br />		nickname = document.getElementsByName('nickname')[0].value;<br />		selectedSource = document.getElementsByName("source")[0].value;<br />		System.Gadget.Settings.writeString('nickname', nickname);<br />		System.Gadget.Settings.writeString('source', selectedSource);<br />	}<br />	event.cancel = false;<br />}<br /><br />System.Gadget.onSettingsClosing = settingsClosing;<br /></pre>При закрытии страницы настроек вызывается событие <code>System.Gadget.onSettingsClosing</code>, которому я присвоил функцию <code>settingsClosing</code>. Значение элементов формы я получаю методом <code>.value</code>, а устанавливаю пункт выпадающего списка методом <code>.selectedIndex</code>.<br /><br />Теперь у нас есть настройки, можно загружать и обрабатывать данные. Создаем новый .js-файл и подключаем его к странице гаджета. Сначала объявим главную функцию и сразу сделаем автообновление данных повтором функции с интервалом в час: <br /><pre>(function work() {<br />// Код<br />setTimeout(work, 3600000)<br />}) ();<br /></pre>Дальнейший код должен находиться внутри этой функции. Чтобы подключить настройки, нужно указать ссылку на соответствующую страницу, как указано в документации к гаджетам: <br /><pre>System.Gadget.settingsUI = 'settings.html';<br /></pre>При первом запуске гаджета настройки еще не указаны, поэтому следует установить настройки по умолчанию: <br /><pre>if (System.Gadget.Settings.readString('nickname') == '') {<br />//Здесь можно указать свой ник для установки по умолчанию<br />	System.Gadget.Settings.writeString('nickname', '');<br />}<br />if (System.Gadget.Settings.readString('source') == '') {<br />	System.Gadget.Settings.writeString('source', 'stats');<br />}<br /></pre>Теперь читаем и применяем настройки: <br /><pre>// Читаем настройки<br />var nickname = System.Gadget.Settings.readString('nickname');<br />// Если введено ID, то тип переменной nickname будет числовым, необходимо привести ее к строковому типу<br />nickname = nickname.toString();<br />var source = System.Gadget.Settings.readString('source');<br />// Собираем персональные ссылки на XML<br />if (nickname.substring(0, 7) == '7656119') { // число 7656119 есть в начале всех ID<br />	urlStats = 'http://steamcommunity.com/profiles/' + nickname + '/stats/CS:S/?xml=1';<br />	urlProfile = 'http://steamcommunity.com/profiles/' + nickname + '/?xml=1';<br />}<br />else { // Никнейм<br />	urlStats = 'http://steamcommunity.com/id/' + nickname + '/stats/CS:S/?xml=1';<br />	urlProfile = 'http://steamcommunity.com/id/' + nickname + '/?xml=1';<br />}<br />// Выводим никнейм в гаджет<br />outputNick = document.getElementById('nick');<br />outputNick.innerHTML = nickname;<br />// В зависимости от настроек выбираем источник данных<br />if (source == 'stats') {<br />	urlSteam = urlStats;<br />}<br />else {<br />	urlSteam = urlProfile;<br />}<br /></pre>Теперь, когда мы применили настройки, можно загружать и парсить XML: <br /><pre>// Функция для загрузки XML<br />function loading() {<br />	if (window.ActiveXObject) { <br />		xmlSteam = new ActiveXObject('Microsoft.XMLDOM');<br />	}<br />	xmlSteam.onreadystatechange = XmlReady;<br />	xmlSteam.load(urlSteam);<br />}<br />// Если XML загрузился, парсим его, если не загрузился - загружаем еще раз<br />function XmlReady() {<br />	if (xmlSteam.readyState == 4) {<br />		if (xmlSteam.childNodes.length == 0) {<br />			loading();<br />		}<br />		else {<br />			if (source == 'stats') {<br />				time_string = xmlSteam.getElementsByTagName('timeplayedfmt')[0].firstChild.data;<br />				time = time_string.substring(0, time_string.lastIndexOf('m') + 1);<br />			}<br />			else {<br />				GamesList = xmlSteam.getElementsByTagName("gameName");<br />				for (i = 0; i &lt; GamesList.length; i++) {<br />					GamesListItem = GamesList[i].childNodes[0].data;<br />					if(GamesListItem == "Counter-Strike: Source") {<br />						time = xmlSteam.getElementsByTagName("hoursOnRecord")[i].firstChild.data + ' hrs';<br />						break;<br />					}<br />				}<br />			}<br />			if (time !== undefined) {<br />				output = document.getElementById('digits');<br />				output.innerHTML = time;<br />			}<br />		}<br />	}<br />}<br /><br />loading();<br /></pre>В предыдущем написанном мной гаджете загрузка XML была синхронной. Но запрос к серверу Стима периодически отваливается, гаджет надолго зависает, часто файл загружается не полностью. Поэтому я выбрал асинхронную загрузку с проверкой статуса. Но даже если на запрос приходил ответ "Completed", иногда оказывалось, что файл загружен не полностью. Поэтому я дополнительно проверяю, есть ли в файле хоть что-то, и если нету, то запускаю функцию загрузки еще раз.<br /><br />С парсингом XML статистики особых сложностей не возникло, берем строку из тега <code>timeplayedfmt</code> и обрезаем из нее секунды, точности до минут вполне хватит. В XML профиля данные о играх находятся в шести блоках <code>mostPlayedGame</code>, в каждом из них есть нужный нам тег <code>hoursOnRecord</code>, но неясно, в каком по счету из этих тегов данные для CS:S. Также в блоке <code>mostPlayedGame</code> находится название игры, поэтому проходимся циклом по тегам <code>gameName</code> и, когда находим значение "Counter-Strike: Source", берем тег <code>hoursOnRecord</code> с таким же номером. Если данные не найдены, в гаджет выводится <code>undefined</code>, поэтому я отсекаю это значение.<br /><br />На этом функция <code>work()</code> заканчивается, остался один штрих. Когда закрывается окно настроек, их необходимо применить сразу, чтобы не ждать час до следующего обновления. Так что навешиваем на системное событие <code>System.Gadget.onSettingsClosed</code> функцию, которая запустит общую (это надо указать в том же файле после функции <code>work()</code>): <br /><pre>System.Gadget.onSettingsClosed = SettingsClosed;<br />function SettingsClosed(event) {<br />	if (event.closeAction == event.Action.commit) {<br />		work();<br />	}<br />}<br /></pre>И еще, если после применения новых настроек данные не будут найдены (например, введен никнейм пользователя, который не играет в CS:S), в гаджет ничего не выведется, и в нем останутся старые значения времени. Поэтому в начале функции work() указываем: <br /><pre>var time = '';<br /></pre>Огромное спасибо <a href="http://vk.com/hakkai" target="_blank">Хикке</a> и&nbsp;<a href="https://twitter.com/justusebrain" target="_blank">theaqua</a> за помощь. Если вам что-то непонятно, можно почитать предыдущие статьи на эту тему:<br /><ul><li><a href="/posts/151">Пишем гаджет Windows 7</a></li><li><a href="/posts/155">Парсинг XML на JavaScript</a></li></ul>В них я подробно рассказывал о аналогичных действиях. Также можно задать вопрос или высказать предложение/замечание в комментариях.<div><br />Вы можете скачать то, что у меня получилось, если вам нужно. Чтобы увидеть исходные файлы, распакуйте гаджет архиватором.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://dl.dropbox.com/u/11765297/css-launcher.gadget" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-EV7JoXhWrio/TQ3HDPLexMI/AAAAAAAAC0k/tercWQVGBaE/s1600/Download.png" /></a></div><br /></div>